<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Xiyu Peng, Jasme Lee" />


<title>Analyzing longitudinal flow cytometry data of Melanoma patients with TopicFlow</title>

<script src="site_libs/header-attrs-2.14/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/united.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/pagedtable-1.1/css/pagedtable.css" rel="stylesheet" />
<script src="site_libs/pagedtable-1.1/js/pagedtable.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>






<link rel="stylesheet" href="styles.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Topic Model in single-cell analysis</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="liver_cancer.html">liver cancer data</a>
</li>
<li>
  <a href="melanoma.html">Melanoma flow data</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Analyzing longitudinal flow cytometry data of Melanoma patients with TopicFlow</h1>
<h4 class="author">Xiyu Peng, Jasme Lee</h4>
<h4 class="date">April 2023</h4>

</div>


<p>Here we present our whole workflow for analyzing longitudinal flow cytometry data from a large cohort study (Starting from FCS file to figures in the manuscript). The study includes 1 clinical trial of 51 melanoma patients who underwent immune checkpoint blockade treatment (ICI) with nivolumab and ipilimumab.</p>
<p>The whole workflow can be mainly divided into two parts:</p>
<ul>
<li><p>Single cell analysis on flow cytometry data (starting with raw FCS file)</p></li>
<li><p>Evaluating pharmacodynamic changes of T cell composition with TopicFlow</p></li>
</ul>
<p>The tutorial provides step-by-step analysis to reproduce key results represented in the manuscript. We show our method TopicFlow allows us to mine tens of millions of single cells from a large collection of patient samples to discover the underlying functional themes that characterize the immune composition and the pharmacodynamics changes in cancer patients.</p>
<p>More details about the study can be found in the manuscript, including the full marker panel for the flow dataset. If you find the tool is useful, please cite our paper.</p>
<p>X. Peng, J. Lee, M. Adamow, C. Maher, M. A. Postow, M. Callahan, K. S. Panageas, R. Shen (2023+). “Uncovering the hidden structure of dynamic T cell composition in peripheral blood during cancer immunotherapy: a topic modeling approach”. (Under Review) <a href="https://doi.org/10.1101/2023.04.24.538095">[bioRxiv]</a></p>
<div class="figure">
<img src="TopicFlow.png" alt="" />
<p class="caption"><strong>Overview of TopicFlow</strong></p>
</div>
<div id="single-cell-flow-cytometry-analysis" class="section level1">
<h1>Single-cell flow cytometry analysis</h1>
<div id="pre-gating-analysis-from-fcs-file-to-single-cell-dataset" class="section level2">
<h2>Pre-gating Analysis: from FCS file to single-cell dataset</h2>
<p>Each Flow Cytometry Standard (FCS) file acquired from the flow cytometry experiments was independently preprocessed using our in-house automated gating pipeline (built with R 4.1.3). The pipeline should be adjusted based on your panel design. The flow panel used in the manuscript is designed for investigating functional T cell subsets:</p>
<ul>
<li>CD3, CD14-CD19, CD4, CD8, FOXP3,</li>
<li>CCR7, CD45RA, CD27, CD28</li>
<li>CD25, CD127, CD57, CXCR5, CCR4</li>
<li>TBET, EOMES, GZMB, KI67, HLA-DR, CD38, GITR, ICOS</li>
<li>LAG3, CTLA4, PD1, TIM3, TIGIT</li>
</ul>
<p>In our analysis, the main preprocessing steps include (See figure below):</p>
<ul>
<li><p>compensation with matrices exported from FlowJo v10.8.0 software (BD Life Sciences).</p></li>
<li><p>biexponential transformation on all marker channels with parameters extra negative decades = 0.5, width basis = -30, positive decades = 4.5 (The file used for transformation can be downloaded from <a href="https://github.com/xiyupeng/topic_modeling/blob/main/data/biexp_transf_parameters_X50.xlsx">here</a>).</p></li>
<li><p>quality control via the R package flowAI (v1.22.0)</p></li>
<li><p>pre-gating up to CD3+ T cells via the R package openCyto (v2.4.0). The pre-gating strategy, as the input to openCyto R package, can be found in <a href="https://github.com/xiyupeng/topic_modeling/blob/main/data/x50_tcell_up_to_cd3_LDA_paper.csv">here</a>.</p></li>
</ul>
<img src="Pre-gating.jpg" title="fig:" style="width:90.0%" alt="Pre-gating T cells from FCS file" />
<details>
<summary>
Click here for R code for the pre-gating steps.
</summary>
<p>R code for key steps in pre-gating process (work in progress)</p>
<pre class="r"><code># Load libraries
library(openCyto)
library(tidyverse)
library(flowCore)
library(glue)
library(flowAI)
library(flowWorkspace)
library(readxl)
library(janitor)

# Set up dynamic variables 
## Below are examples
## String: sample name
pt_samp_nm = &quot;flow_sample_1&quot;

## File path to the FCS file
path_fcs = &quot;./flow_sample_1.fcs&quot;

## File path to the compensation matrix csv file
## Expect format to match flowJo exported version
path_comp_mat = &quot;./flow_sample_1_comp_mat.csv&quot;

## File path for outputs/saving
path_out = &quot;./output&quot;

## File path to gating template
gtFile = &quot;./flow_tcell_gating_template.csv&quot;

## File path to biexp parameters
## Expects 4 columns: full_name, ext_neg_dec, width_basis, positive_dec
## full name should contain the channel/dye name
#3 remaining cols fill in with desired parameter values
path_biexp_params = &quot;./flow_biexp_param.xlsx&quot;

# Load gating template
## Modified the T cell gating template from {openCyto}

### Read in file
dtTemplate = data.table::fread(gtFile)

### Load
gt_tcell = openCyto::gatingTemplate(gtFile)

# Optional to check the template
# gt_tcell
# plot(gt_tcell)


# Import FCS, Build GatingSet
## read in the fcs files
cs  &lt;- flowWorkspace::load_cytoset_from_fcs(glue::glue(&quot;{path_fcs}&quot;))

## change &quot;Viability&quot; or &quot;L/D&quot; to = &quot;L_D&quot; for consistency
{if(any(c(&quot;Viability&quot;, &quot;L/D&quot;, &quot;LD&quot;) %in% flowWorkspace::markernames(cs))){
  aux_log = flowWorkspace::markernames(cs) == &quot;Viability&quot; | flowWorkspace::markernames(cs) == &quot;L/D&quot; | flowWorkspace::markernames(cs) == &quot;LD&quot;
  
  markernames(cs) = replace(markernames(cs), aux_log, &quot;L_D&quot;)}
}

## Create a GatingSet of 1 sample
gs = flowWorkspace::GatingSet(cs)

# Compensation
## Import comp. mat. csv exported from flowJo
comp.mat = read.csv(path_comp_mat,
                    header = TRUE, 
                    skip = 0) 

## Optional to check comp mat
## comp.mat %&gt;%
##   head

## Can remove the X col because that&#39;s the row names 
comp.mat = 
  comp.mat %&gt;% 
  column_to_rownames(var = &quot;X&quot;)

## clean up the col names of the comp.mat 
marker_chnl_names = 
  tibble::tibble(colnms = colnames(comp.mat)) %&gt;% 
  tidyr::separate(colnms, c(&quot;chnl&quot;, &quot;marker&quot;), sep = &quot;\\.\\.\\.\\.&quot;, remove = FALSE)

## further clean up some of the col nanmes to match channel names in `gs`
comp.mat = 
  comp.mat %&gt;% 
  dplyr::rename(stats::setNames(marker_chnl_names$colnms, gsub(&quot;\\.&quot;, &quot;-&quot;, marker_chnl_names$chnl))) %&gt;% 
  {if(&quot;PE.Cy5.5.A&quot; %in% marker_chnl_names$chnl) rename(., &quot;PE-Cy5.5-A&quot; = &quot;PE-Cy5-5-A&quot;)
    else rename(.)} %&gt;% 
  {if(&quot;Alexa.Fluor.700.A&quot; %in% marker_chnl_names$chnl) rename(., &quot;Alexa Fluor 700-A&quot; = &quot;Alexa-Fluor-700-A&quot;)
    else rename(.)} %&gt;% 
  {if(&quot;Horizon.V450.A&quot; %in% marker_chnl_names$chnl) rename(., &quot;Horizon V450-A&quot; = &quot;Horizon-V450-A&quot;)
    else rename(.)} %&gt;% 
  {if(&quot;Pacific.Orange.A&quot; %in% marker_chnl_names$chnl) rename(., &quot;Pacific Orange-A&quot; = &quot;Pacific-Orange-A&quot;)
    else rename(.)} %&gt;% 
  {if(&quot;Qdot.605.A&quot; %in% marker_chnl_names$chnl) rename(., &quot;Qdot 605-A&quot; = &quot;Qdot-605-A&quot;)
    else rename(.)} %&gt;% 
  {if(&quot;Qdot.655.A&quot; %in% marker_chnl_names$chnl) rename(., &quot;Qdot 655-A&quot; = &quot;Qdot-655-A&quot;)
    else rename(.)}


# ## Check col names are equal
# colnames(comp.mat) == (colnames(cs) %&gt;% .[!(grepl(&quot;FSC|SSC|Time&quot;, .))])

## Create the `compensation` object with `flowCore::compensation()`
comp = flowCore::compensation(comp.mat)

## Apply compensation to the `GatingSet` with `flowCore::compensate()`
### Must have the colnames in `comp.mat` match the channel names in the `cytoset` 
gs = flowCore::compensate(gs, comp)


# Transformation
## Read in the table of parameters
tbl_biexp_params = 
  readxl::read_xlsx(path_biexp_params) %&gt;% 
  janitor::clean_names(case = &quot;all_caps&quot;) 

## loop through all the channels and create a biexpTrans object per channel
biexpTrans = 
  purrr::pmap(
    list(p = tbl_biexp_params$POSITIVE_DEC,
         n = tbl_biexp_params$EXT_NEG_DEC, 
         wb = tbl_biexp_params$WIDTH_BASIS),
    function(p, n, wb, ...){
      flowWorkspace::flowjo_biexp_trans(pos = p,
                                        neg = n,
                                        widthBasis = wb)
      
    }
  )


## Give names
names(biexpTrans) = tbl_biexp_params$FULL_NAME


## Optional - Checks that all channels have a matching biexpTrans object
# lapply(biexpTrans, 
#        FUN = function(x){x[[&quot;transform&quot;]] %&gt;% attr(., &quot;parameters&quot;)}) %&gt;% 
#   dplyr::bind_rows(.id = &quot;channel&quot;) 
# 
# ## Do channel names match the names of biexpTrans?
# all(names(biexpTrans) %in% parameters(comp))
# all(names(biexpTrans) %in% names(markernames(gs)))

## Create transformerList in order to apply to gs
trans = transformerList(names(biexpTrans), biexpTrans)

## Optional - Check the values before transformation
# gs %&gt;% 
#   gh_pop_get_data() %&gt;% 
#   summary()

## Apply to gs
gs = transform(gs, trans)

## optional - Check values after transformation
# gs %&gt;% 
#   gh_pop_get_data() %&gt;% 
#   summary()

# Quality/time gate with {flowAI}
## function expect flowSet/flowFrame as input rather than a GatingSet
## use flowWorkspace::gh_pop_get_data() to grab the flowSet
## User can define where to save outputs for report from {flowai]}

## If dir doesn&#39;t exist, create one
if(!dir.exists(here::here(glue(&quot;{path_out}/flowAI_results&quot;)))){
  dir.create(here::here(glue(&quot;{path_out}/flowAI_results&quot;)))
}

qc = flowAI::flow_auto_qc(flowWorkspace::gh_pop_get_data(gs),
                          folder_results = here::here(glue(&quot;{path_out}/flowAI_results&quot;)))

## Convert to a flowSet in order to convert back to GatingSet
qc_fs = 
  qc %&gt;% 
  # First convert to a flowSet
  flowCore::flowSet()

## Rename the sample 
flowCore::sampleNames(qc_fs) = pt_samp_nm

## convert the flowFrame obj returned in qc_fs to a GatingSet to pass to openCyto
gs_qc =  
  qc_fs %&gt;% 
  flowWorkspace::GatingSet()

## Remote the qc_fs object as it&#39;s no longer needed
rm(qc_fs)

# Pre-gating up to CD3+ with {openCyto}
## Set seed using today&#39;s date 
set.seed(glue::glue({format(Sys.Date(), format = &quot;%Y%m%d&quot;)}))

openCyto::gt_gating(gt_tcell, gs_qc)

# Extract intensity matrix from GatingSet object
## Grab marker names from GatingSet for labeling col names in intensity matrix
marker_chnl_names = 
  flowWorkspace::gh_pop_get_data(gs_qc) %&gt;% 
  flowWorkspace::markernames() %&gt;% 
  as.data.frame() %&gt;% 
  tibble::rownames_to_column() %&gt;% 
  dplyr::rename(chnl = rowname, 
         marker_full = &quot;.&quot;) %&gt;% 
  # clean up the names 
  dplyr::mutate(
    marker_full = janitor::make_clean_names(marker_full, replace = c(&quot;-&quot; = &quot;&quot;, &quot;_&quot; = &quot;&quot;, &quot; &quot; = &quot;&quot;)) %&gt;% toupper()
  ) %&gt;% 
  # Reorder the marker channel names to start with CD3, CD4, CD8 then the rest
  dplyr::arrange(match(marker_full, c(&quot;CD3&quot;, &quot;CD4&quot;, &quot;CD8&quot;))) %&gt;% 
  # Clean up
  dplyr::mutate(marker_full = ifelse(marker_full == &quot;FOX_P3&quot;, &quot;FOXP3&quot;, marker_full))

## Grab the intensity matrix from GatingSet
## the gh_pop_get_indices grabs the 0/1 for whether gated as CD3
intensity_dat = 
  gs_qc %&gt;% 
  flowWorkspace::gh_pop_get_indices(y = &quot;cd3&quot;) %&gt;% 
  cbind(gs_qc %&gt;%  
          flowWorkspace::gh_pop_get_data() %&gt;% 
          flowCore::exprs(),
        &quot;cd3_pos&quot; = .) %&gt;% 
  tibble::as_tibble() %&gt;%
  # Rename for plotting
  dplyr::rename(stats::setNames(marker_chnl_names$chnl, as.character(marker_chnl_names$marker_full))) 

## Preview of intensity matrix
head(intensity_dat)</code></pre>
</details>
<p>The output from pre-gating is an intensity matrix with rows corresponding to each cell, and columns corresponding to the time, forward and side scatters, and intensity values for marker and an indicator column for whether the cell is CD3 +/- (indicated as 1/0).</p>
</div>
<div id="quality-control" class="section level2">
<h2>Quality control</h2>
<p>When integrating multiple samples, it is important to check if there is a batch effect. To evaluate the possible batch effect, ridge plots can help to check the consistency of transformed intensity values across multiple patient samples, as the example shown below. These ridge plots can be easily made with the help of the <a href="https://satijalab.org/seurat/index.html">Seurat</a> R package. From the figure shown below, we can find the transformed intensity values of all markers are roughly on the same scale.</p>
<div class="figure">
<img src="Ridgeplot.png" alt="" />
<p class="caption"><strong>Using ridge plot to check batch effect</strong></p>
</div>
<p>We also recommend to downsample cells from each sample and use UMAP to check if there is a significant batch effect. You may visually assess the UMAP plots and check if there is a significant batch effect among patient samples.</p>
</div>
<div id="single-cell-clustering-analysis" class="section level2">
<h2>Single-cell clustering analysis</h2>
<p>For better visualization and analysis, we choose to use <a href="https://mojaveazure.github.io/seurat-object/index.html">Seurat Object</a>, a data structure provided by the <a href="https://satijalab.org/seurat/index.html">Seurat</a> R package, to store single cell data. We provide the seurat objects (in rds files) of three patients as examples. They can be downloaded from <a href="https://data.mendeley.com/datasets/d7nkgfhc8z">here</a>. For each flow sample (FCS file), there are about 100k cells on average. For our panel, 29 markers (include live/dead, CD14-CD19 with shared fluorescence) are measured for each single cell.</p>
<p>For pooled clustering analysis, we pool all T cells from all patient samples together. We use the Louvain algorithm, a graph-based algorithm for clustering cells. Louvain is the core algorithm of <a href="https://github.com/jacoblevine/PhenoGraph">PhenoGraph</a>, the famous python library for clustering flow cytometry data. The data file <code>seurat_object_17162_rerun_all_dim26.rds</code>, containing cells aggregated from all 138 samples in the analysis, is too big to be read by a standard laptop. We recommend to do the following analysis on a server with adequate memory space available.</p>
<p>The code below was run on a server. We requested 250GB memory space for analyzing 17M+ T cell. It ran for about 5 days.</p>
<pre class="r"><code>library(Seurat)
library(future)
## parallel computing 
plan(&quot;multiprocess&quot;, workers = 8)
plan()
## increase the maximal size of a data object in R
options(future.globals.maxSize = 100000 * 1024^2)

### data_real_marks (n_cells x n_markers)
### is a matrix of marker intensity values of all T cells (CD3+)
### with each row corresponding to each cell, 
### and each column corresponding to each marker (27 markers in total)
#pool_X50 &lt;- CreateSeuratObject(counts = t(data_real_marks), project = &quot;17-162&quot;)
#pool_X50
#pool_X50[[&#39;time&#39;]]&lt;-factor(time)
#pool_X50[[&#39;patient&#39;]]&lt;-factor(patient)
#pool_X50[[&#39;sample&#39;]]&lt;-factor(sample)
### read the pre-saved data
pool_X50 &lt;- readRDS(file = &quot;seurat_object_17162_rerun_all_dim26.rds&quot;)

## All 27 markers are variable markers across cells
## This step seems unnecessary but it cannot be skipped
pool_X50 &lt;- FindVariableFeatures(object = pool_X50)

### scale each markers
all.genes &lt;- rownames(pool_X50)
pool_X50 &lt;- ScaleData(pool_X50, features = all.genes)

### PCA
pool_X50 &lt;- RunPCA(pool_X50, features = all.genes,approx=FALSE,npcs = 26)

### UMAP based on 26 PCs. 
### Use min.dist = 0.1 for better separation
### Recommend the default 0.3 for visualizing each patient samples
pool_X50 &lt;- RunUMAP(pool_X50, dims = 1:26,min.dist = 0.1)

### Construct KNN graph with a fast nearest neighbor search using RANN
pool_X50 &lt;- FindNeighbors(pool_X50, dims = 1:26, nn.eps = 0.5,k.param = 5)

### Clustering cell with Louvain method based on KNN under different resolutions
### This step would be run in parallel
res&lt;-c(0.5, 0.8, 1, 1.2, 1.5, 2, 2.5, 3)
pool_X50 &lt;- FindClusters(pool_X50, resolution = res)

saveRDS(pool_X50, file = &quot;seurat_object_17162_rerun_all_dim26.rds&quot;)</code></pre>
<div id="alternative-approach" class="section level3">
<h3>Alternative approach</h3>
<p>The pooled clustering strategy may not be applicable for a larger cohort study. We are working on a pipeline using <a href="https://doi.org/10.1038/s41596-021-00550-0">FlowSOM</a> for cell clustering. In FlowSOM, cells in each patient samples will be independently over-clustered using a self-organizing map (SOM, also a graph-based clustering method), then followed by a consensus clustering (using R package <a href="https://bioconductor.org/packages/release/bioc/html/ConsensusClusterPlus.html">ConsensusClusterPlus</a>) to generate meta-clusters (clusters of clusters within each sample). You may check the <a href="https://doi.org/10.1038/s41596-021-00550-0">protocol</a> of FlowSOM for further details. With the limited experience, the consensus clustering is expected to be the most time and memory consuming step in the analysis pipeline.</p>
<p>Codes below show an example how to convert the data to a FlowSOM object.</p>
<pre class="r"><code>### select data for a single patient
pt_seurat&lt;-subset(pool_X50,subset = patient == &quot;17-162-03&quot;)
### convert to FlowSOM object
data_FlowSOM&lt;-flowCore::flowFrame(t(as.matrix(pt_seurat[[&#39;RNA&#39;]]@data)))
tmp &lt;- FlowSOM::ReadInput(data_FlowSOM, transform = FALSE, scale = FALSE)</code></pre>
<p>For either clustering approach, you have to tune parameters to determine the number of clusters. For our melanoma dataset, we chose the clustering solution under resolution 1.5 with the highest average Silhouette scores. But once you have selected your clustering results, you can output cell count matrix (<code>clusterbysample</code>) per cluster per sample and visualize the clustering results with UMAP.</p>
<pre class="r"><code>## choose resolution = 1.5
Idents(pool_X50)&lt;-&quot;RNA_snn_res.1.5&quot;
## output cell count per cluster per sample
clusterbysample&lt;-table(pool_X50$sample,Idents(pool_all_X50))
## plot UMAP for the whole cohort
DimPlot(subset(pool_X50, idents = 1:20),reduction = &quot;umap&quot;, label = TRUE)</code></pre>
<p>Figure below shows the UMAP plot for a single patient. We annotate key clusters based on their marker expression.</p>
<center>
<img src="UMAP.jpg" title="fig:" style="width:60.0%" alt="T cells of a single patient" />
</center>
<p>The cell count matrix <code>clusterbysample</code> contains cell type abundance for each flow sample. We further add sample information for each sample, including sample collection time and patient info, and clinical annotation for each patient, including response, toxicity, and survival data.</p>
<p>As a tutorial for TopicFlow, the following analysis will use the supplementary data of the manuscript as the input. The supplementary data can be downloaded from <a href="https://github.com/xiyupeng/topic_modeling/blob/main/data/Supplementary%20Data%20File%20S1.csv">here</a>.</p>
</div>
</div>
</div>
<div id="explore-sample-level-heterogeneity-with-topicflow" class="section level1">
<h1>Explore sample-level heterogeneity with TopicFlow</h1>
<div id="getting-ready" class="section level2">
<h2>Getting ready</h2>
<p>Firstly, we have to install core R packages required for LDA analysis. We use the R package <em>topicmodels</em> for model inference, R package <em>slam</em> for preparing the input data, R package <em>tidytext</em> for extracting the output data.</p>
<pre class="r"><code>library(topicmodels)
library(slam)
library(tidytext)</code></pre>
<p>In this workflow, we use some R packages for data visualization and analysis. But these R packages are not necessary, you can use other similar R packages instead.</p>
<pre class="r"><code>library(tidyverse)
library(ComplexHeatmap)
library(ggpubr)
library(patchwork)</code></pre>
<p>First, we read in the supplementary data file of the manuscript. The file contains the cell type count for individual samples (as the result of the clustering analysis), as well as patient clinical information.</p>
<pre class="r"><code>X50_result&lt;-read.csv(file = &quot;https://raw.githubusercontent.com/xiyupeng/topic_modeling/main/data/Supplementary%20Data%20File%20S1.csv&quot;)
X50_result&lt;-X50_result[1:138,]  ## remove empty rows at the bottom
## toxicity 
X50_result$tox&lt;-as.factor(X50_result$irAE...grade.2)
## response 
X50_result$res&lt;-as.factor(X50_result$Best.Overall.Response)
levels(X50_result$res)&lt;-c(&quot;CR/PR&quot;,&quot;PD/SD&quot;,&quot;CR/PR&quot;,&quot;PD/SD&quot;)
## time point
X50_result$Timepoint &lt;-as.factor(X50_result$Timepoint)
X50_result$week&lt;-X50_result$Timepoint 
levels(X50_result$week)&lt;-c(&quot;0&quot;,&quot;3&quot;,&quot;6&quot;)</code></pre>
<p>The final input data matrix for LDA has 138 samples with 20 features (clusters), while each entry is number of cells per cluster per sample.</p>
<pre class="r"><code>## Only focus on first 20 clusters
X50_result %&gt;% select(starts_with(&quot;cluster&quot;))-&gt;data_matrix
data_matrix&lt;-data_matrix[,1:20]
head(data_matrix[,1:8])</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["cluster0"],"name":[1],"type":["int"],"align":["right"]},{"label":["cluster1"],"name":[2],"type":["int"],"align":["right"]},{"label":["cluster2"],"name":[3],"type":["int"],"align":["right"]},{"label":["cluster3"],"name":[4],"type":["int"],"align":["right"]},{"label":["cluster4"],"name":[5],"type":["int"],"align":["right"]},{"label":["cluster5"],"name":[6],"type":["int"],"align":["right"]},{"label":["cluster6"],"name":[7],"type":["int"],"align":["right"]},{"label":["cluster7"],"name":[8],"type":["int"],"align":["right"]}],"data":[{"1":"22088","2":"24867","3":"13141","4":"1441","5":"7755","6":"2226","7":"12081","8":"6480","_rn_":"1"},{"1":"10363","2":"8900","3":"4437","4":"897","5":"6271","6":"769","7":"3709","8":"2047","_rn_":"2"},{"1":"54829","2":"44966","3":"20226","4":"6102","5":"15656","6":"6634","7":"29310","8":"11716","_rn_":"3"},{"1":"11159","2":"12832","3":"10028","4":"7671","5":"7280","6":"1577","7":"935","8":"2926","_rn_":"4"},{"1":"3894","2":"5698","3":"3219","4":"5099","5":"8561","6":"2468","7":"597","8":"812","_rn_":"5"},{"1":"13495","2":"24372","3":"3708","4":"32126","5":"5716","6":"11531","7":"2678","8":"3786","_rn_":"6"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
</div>
<div id="model-inference" class="section level2">
<h2>Model inference</h2>
<p>We use the <em>topicmodels</em> R package for model inference. We use Gibbs sampling algorithm and choose number of topics K = 3:</p>
<ul>
<li><p><strong>Gibbs sampling</strong>. The <em>topicmodels</em> R package provides two algorithms, variation EM and Gibbs sampling, for model inference. The two different algorithms may contribute to different results (See the <a href="https://cran.microsoft.com/snapshot/2016-09-30/web/packages/topicmodels/vignettes/topicmodels.pdf">documentation</a> of the <em>topicmodels</em> R package). But in the example given in the R package, the Gibbs sampling algorithm seems to return better models than Variation EM. Thus we prefer Gibbs sampling in the analysis. We used the following setting for Gibbs sampling: iter = 1000, burnin = 1000, thin = 100 (1000 Gibbs sampling draws are made with the first 1000 iterations discarded and then every 100th iteration kept).</p></li>
<li><p><strong>K = 3</strong>. Number of topics K also needs to be selected before running the model inference. There is no “right” answer to the number of topics that are the most appropriate for data. You may use R package <em>ldatuning</em> or cross-validation to select number of topics K. In this case, we failed to select the number of topics with a 10-fold cross-validation, likely a reflection of the size of the dataset (only 138 samples). Thus, we guided the choice of the number of topics based on what is most useful for scientific interpretation. Moreover, during the cross-validation, we observed the biggest drop in perplexity40 (a measure of how successfully a trained topic model predicts new data) is between K = 2 and K = 3. Thus we set K = 3 in this study.</p></li>
</ul>
<p>The Gibbs sampling will take several minutes. We can save the result here for further analysis. The pre-ran LDA results can be downloaded from <a href="https://github.com/xiyupeng/topic_modeling/blob/main/data/lda_example_K3.Rdata">here</a>.</p>
<p>Note: Gibbs sampling is a stochastic algorithm, but the result for this dataset is relatively stable. If you choose to run LDA yourself with a different random seed or change the order of the input data, you may have to switch the order of the three topics to match the results. But generally you should be able to identify the three topics which we will describe below: activation topic, exhaustion topic, and naive topic.</p>
<pre class="r"><code>require(slam)
require(topicmodels)

count_matrix_triplet &lt;- as.simple_triplet_matrix(data_matrix)

lda&lt;-LDA(count_matrix_triplet, control = list(seed = 2021, burnin = 1000,thin = 100, iter = 1000), k = 3, method = &quot;Gibbs&quot;)

save(lda, file = &quot;~/flow_cytometry/lda/lda_example_K3.Rdata&quot;)</code></pre>
<p>Below we reload the data and check the output of the LDA model.</p>
<pre class="r"><code>## load the data
load(file = &quot;~/flow_cytometry/lda/lda_example_K3.Rdata&quot;)
ntopics = 3

## extract output of the LDA model
para&lt;-posterior(lda)
colnames(para$topics)&lt;-paste0(&quot;topic&quot;,colnames(para$topics))
rownames(para$terms)&lt;-paste0(&quot;topic&quot;,rownames(para$terms))

#### update to the meta data
X50_result$topics&lt;-topics(lda)
X50_result&lt;-as.data.frame(cbind(X50_result,para$topics))</code></pre>
<p>The main output of the LDA model contains two matrices:</p>
<ol style="list-style-type: decimal">
<li><strong>Topic content matrix</strong> (cell type-by-topic matrix) represents topics as different discrete distributions over cell types (clusters)</li>
</ol>
<pre class="r"><code>## show first five columns
head(round(para$terms[,1:5],3))</code></pre>
<pre><code>##        cluster0 cluster1 cluster2 cluster3 cluster4
## topic1    0.000    0.058    0.003    0.372    0.019
## topic2    0.219    0.159    0.176    0.010    0.053
## topic3    0.053    0.138    0.000    0.030    0.202</code></pre>
<ol start="2" style="list-style-type: decimal">
<li><strong>Topic prevalence matrix</strong> (topic-by-sample matrix) displays topic proportions estimated per sample</li>
</ol>
<pre class="r"><code>## show first five rows
head(round(para$topics,3))</code></pre>
<pre><code>##   topic1 topic2 topic3
## 1  0.009  0.972  0.018
## 2  0.005  0.636  0.359
## 3  0.037  0.882  0.081
## 4  0.164  0.664  0.172
## 5  0.189  0.193  0.618
## 6  0.541  0.406  0.053</code></pre>
<p>The topic prevalence matrix will be merged with the original data frame for further analysis. But before investigating the distribution of topics over patient samples, we want to exam the topic content matrix and interpret each topic by selecting representative cell types.</p>
</div>
<div id="topic-content" class="section level2">
<h2>Topic content</h2>
<p>The intepretability of topic models is a key advantage. In text analysis, representative terms, in this case, representative clusters, are used to define topics. Sometimes people directly use the topic weights in topic content matrix to select representative terms.</p>
<p>In this case, you can simply find clusters with top weight for each topic with <code>terms()</code>,</p>
<pre class="r"><code>terms(lda,5)</code></pre>
<pre><code>##      Topic 1     Topic 2    Topic 3    
## [1,] &quot;cluster3&quot;  &quot;cluster0&quot; &quot;cluster4&quot; 
## [2,] &quot;cluster5&quot;  &quot;cluster2&quot; &quot;cluster8&quot; 
## [3,] &quot;cluster14&quot; &quot;cluster1&quot; &quot;cluster1&quot; 
## [4,] &quot;cluster13&quot; &quot;cluster6&quot; &quot;cluster12&quot;
## [5,] &quot;cluster1&quot;  &quot;cluster7&quot; &quot;cluster9&quot;</code></pre>
<p>or visualize them with barplots.</p>
<pre class="r"><code>### beta
ap_topics &lt;- tidy(lda, matrix = &quot;beta&quot;)
ap_topics$topic&lt;-as.factor(paste0(&quot;topic&quot;,ap_topics$topic))

### make barplots
ap_topics$term&lt;-gsub(&quot;cluster&quot;,&quot;&quot;,ap_topics$term)
term_reorder&lt;-as.character(c(0,2,6,11,9,8,7,1,4,10,12,14,15,3,5,13,16,17,18,19))
ggbarplot(ap_topics, x = &quot;term&quot;, y = &quot;beta&quot;,color = &quot;topic&quot;,fill = &quot;topic&quot;,palette = c(&quot;#D55E00&quot;, &quot;#009E73&quot;, &quot;#0072B2&quot;),facet.by = &quot;topic&quot;,nrow = 3)+xlab(&quot;T cell cluster&quot;)+scale_x_discrete(limits = term_reorder)+ylab(&quot;topic weight&quot;)</code></pre>
<p><img src="melanoma_files/figure-html/unnamed-chunk-14-1.png" width="384" style="display: block; margin: auto;" /></p>
<p>One main drawback of using topic weight to select representatives is that high abundant clusters with little variation are likely to be selected as representatives due to their high topic weights. In our analysis, the top representative clusters from each topic are selected after ranking by lift, which is the log ratio of estimated topic weights over its empirical frequency. The lift metric gives higher weights to clusters that appear less frequently in other topics. This metric was proposed by Matt Taddy in the paper <em>On Estimation and Selection for Topic Models</em>, and is also used in the R package <em>stm</em> for <a href="https://www.structuraltopicmodel.com/">structure topic model</a>.</p>
<p>Below we show top 10 clusters with top lift for each topic. In practice, we find the metric lift provides the most interpretable results, helping to select representative clusters for each topic. Thus we can name each topic based upon the most representative cell clusters ranked by lift:</p>
<ul>
<li>Topic 1 (orange) mainly contains two CD8 Temra clusters (clusters 3 and 5), one CD4 cytotoxic Tem cluster (cluster 14, GzmB+), and one CD4-CD8- cluster (cluster 13). Thus we named it the <strong>Exhaustion topic</strong>.</li>
<li>Topic 2 (green) we labeled the <strong>Naive topic</strong>, with CD4+ and CD8+ naive T cell clusters identified as the most representative clusters</li>
<li>Topic 3 (blue) is an <strong>Activation topic</strong>: The five representative cell clusters we identified include two CD4 T cell clusters (clusters 8 and 4), one CD8 T cell cluster (cluster 12), one Treg cluster (cluster 9), and one CD4-CD8- T cell cluster (cluster 16). Most of clusters of topic 3 are KI67+ and they are expanding upon ICI treatment!</li>
</ul>
<pre class="r"><code>### calculate the lift
wordcounts &lt;- colSums(data_matrix)
logbeta &lt;- lda@beta
emp.prob &lt;- log(wordcounts) - log(sum(wordcounts))
lift &lt;- logbeta - rep(emp.prob, each = nrow(logbeta))
colnames(lift)&lt;-lda@terms
lift&lt;-as.data.frame(lift)
lift$topics&lt;-paste0(&quot;topic&quot;,1:3)

#### name three topics based on the content
new_label&lt;-c(&quot;Exhaustion Topic&quot;,&quot;Naive Topic&quot;,&quot;Activation Topic&quot;)
names(new_label)&lt;-c(&quot;topic1&quot;,&quot;topic2&quot;,&quot;topic3&quot;)

### show top 10 representative clusters for each topic
lift_top_terms &lt;- lift %&gt;% gather(.,key = cluster,value = lift,-topics) %&gt;%
  group_by(topics) %&gt;%
  slice_max(lift, n = 10) %&gt;% 
  ungroup() %&gt;%
  arrange(topics, -lift)

lift_top_terms %&gt;%
  mutate(cluster = reorder_within(cluster, lift, topics)) %&gt;%
  ggplot(aes(lift, cluster, fill = factor(topics))) +
  geom_col(show.legend = FALSE,orientation = &quot;y&quot;) +
  facet_wrap(~ topics, scales = &quot;free&quot;,labeller = labeller(topics = new_label)) + 
  scale_y_reordered()+theme_bw()+scale_fill_manual(values=c(&quot;#D55E00&quot;, &quot;#009E73&quot;, &quot;#0072B2&quot;))+
  xlab(&quot;lift (log-ratio of topic weight over T cell cluster frequency)&quot;)+ylab(&quot;T cell cluster&quot;)</code></pre>
<p><img src="melanoma_files/figure-html/unnamed-chunk-15-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<div id="topic-prevalence" class="section level2">
<h2>Topic Prevalence</h2>
<p>Below we use heatmap and stackplot to visualize the distribution of topics across patients.</p>
<div id="heatmap" class="section level3">
<h3>heatmap</h3>
<p>In the heatmap, the <strong>activation topic</strong> mainly captures the expansion of Tcm/em upon treatment. For most patients, the proportion of the <strong>activation topic</strong> is near zero (dark blue) in pre-treatment samples (week 0). This topic emerges on-treatment as seen by the increase of topic proportions in weeks 3 and 6 samples. At baseline (week 0), most of the patient samples are characterized by a high presence of the <strong>naïve topic</strong>, which subsequently decreases after ICI treatment as cells transition into more “activated” states. In contrast, a small subgroup of patient samples (group1) has a low proportion of the <strong>naïve topic</strong>, but a high fraction of the <strong>exhaustion topic</strong> presented at week 0. There is no visible reduction in the exhausted T cell population after ICI treatment.</p>
<p>We first set up parameters for the heatmap, including color, annotations for rows and columns.</p>
<pre class="r"><code>## set color for the heatmap
ann_colors = list(
  BOR = c(CR = &quot;white&quot;,PR = &quot;white&quot;, SD = &quot;firebrick&quot;,PD = &quot;firebrick&quot;),
  Toxicity = c(N = &quot;white&quot;,Y = &quot;darkblue&quot;),
  topics = c(`1` = &quot;#0072B2&quot;, `2` = &quot;#009E73&quot;,`3` = &quot;#D55E00&quot;,Activation = &quot;#0072B2&quot;, Naive = &quot;#009E73&quot;, Exhaustion = &quot;#D55E00&quot; ),
  Immunotype = c(&quot;LAG-&quot; =  &quot;#555599&quot;, &quot;LAG+&quot; =  &quot;#66BBBB&quot;, PRO = &quot;#DD4444&quot;),
  Group = c(group1 = &quot;#7570B3&quot;, group2 = &quot;#E7298A&quot;, group3 = &quot;#66A61E&quot;,group4 = &quot;#D95F02&quot;)
)

## Annotation columns
annotation_column = data.frame(
  topics = factor(rep(c(&quot;Exhaustion&quot;,&quot;Naive&quot;,&quot;Activation&quot;),each = 3))
)

## Annotation rows
pt_meta&lt;-X50_result %&gt;% select(PatientID,Immunotype,tox,Best.Overall.Response) %&gt;% arrange(PatientID) %&gt;% distinct(PatientID,.keep_all = TRUE)
colnames(pt_meta)&lt;-c(&quot;pt&quot;,&quot;Immunotype&quot;,&quot;Toxicity&quot;,&quot;BOR&quot;)
rownames(pt_meta)&lt;-pt_meta$pt</code></pre>
<p>Then we reshape the topic prevalence matrix and prepare for the data for making the heatmap. We make each row in the heatmap for each patient, while each cell is the topic fraction of one flow sample at one timepoint.</p>
<pre class="r"><code>## reshape the gamma matrix (topic fraction) for heatmap representation
rownames(para$topics)&lt;-X50_result$sample
gamma_data&lt;-as.data.frame(para$topics)
gamma_data$pt&lt;-as.factor(X50_result$PatientID)
gamma_data$time&lt;-as.factor(X50_result$Timepoint)
gamma_wide_wna&lt;-gamma_data %&gt;% arrange(pt, time)%&gt;%reshape(.,timevar = &quot;time&quot;,idvar = &quot;pt&quot;,direction = &quot;wide&quot;) ## keep missing value as NA in the matrix
rownames(gamma_wide_wna)&lt;-gamma_wide_wna$pt
head(gamma_wide_wna)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["pt"],"name":[1],"type":["fct"],"align":["left"]},{"label":["topic1.A"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["topic2.A"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["topic3.A"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["topic1.B"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["topic2.B"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["topic3.B"],"name":[7],"type":["dbl"],"align":["right"]},{"label":["topic1.C"],"name":[8],"type":["dbl"],"align":["right"]},{"label":["topic2.C"],"name":[9],"type":["dbl"],"align":["right"]},{"label":["topic3.C"],"name":[10],"type":["dbl"],"align":["right"]}],"data":[{"1":"17-162-03","2":"0.009041834","3":"0.9724595","4":"0.018498683","5":"0.004836218","6":"0.6358586","7":"0.3593051","8":"0.03702493","9":"0.8821435","10":"0.08083156","_rn_":"17-162-03"},{"1":"17-162-04","2":"0.164024045","3":"0.6637842","4":"0.172191755","5":"0.189175217","6":"0.1932827","7":"0.6175421","8":"NA","9":"NA","10":"NA","_rn_":"17-162-04"},{"1":"17-162-05","2":"0.541153564","3":"0.4059505","4":"0.052895913","5":"0.514424171","6":"0.2528074","7":"0.2327684","8":"0.36264654","9":"0.1611609","10":"0.47619255","_rn_":"17-162-05"},{"1":"17-162-06","2":"0.503885702","3":"0.4915277","4":"0.004586648","5":"0.414744295","6":"0.2557640","7":"0.3294917","8":"0.34684247","9":"0.4705902","10":"0.18256733","_rn_":"17-162-06"},{"1":"17-162-07","2":"0.149698007","3":"0.7733740","4":"0.076928015","5":"NA","6":"NA","7":"NA","8":"0.13317994","9":"0.6331067","10":"0.23371339","_rn_":"17-162-07"},{"1":"17-162-08","2":"0.098330457","3":"0.7861724","4":"0.115497130","5":"NA","6":"NA","7":"NA","8":"NA","9":"NA","10":"NA","_rn_":"17-162-08"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>Patient 17-162-08 was excluded since this patient only has week 0 sample and made trouble for making the heatmap, because there are other two patients missing week 0 sample (seen in the heatmap below).</p>
<pre class="r"><code>## exclude pt 17-162-08 in the meta data
pt_meta_wo6&lt;-pt_meta[-6,]  

## we want to use the order of patients (rows) outside the heatmap.
## Thus patients are pre-grouped before heatmap
ourdist&lt;-dist(gamma_wide_wna[-6,-1])  ## again, excluding pt 17-162-08 
re&lt;-hclust(ourdist)
group&lt;-as.data.frame(cutree(re,5))  
colnames(group)&lt;-&quot;Group&quot;
pt_meta_wo6&lt;-cbind(pt_meta_wo6,group)
pt_meta_wo6$Group&lt;-factor(pt_meta_wo6$Group)
levels(pt_meta_wo6$Group)&lt;-c(&quot;group4&quot;,&quot;group3&quot;,&quot;group1&quot;,&quot;group2&quot;,&quot;group1&quot;)

## reorder columns by each topic in the heatmap (still excluding pt 17-162-08)
gamma_wide_wna_reorder&lt;-gamma_wide_wna[-6,order(colnames(gamma_wide_wna))]
col_labels&lt;-rep(c(&quot;week0&quot;,&quot;week3&quot;,&quot;week6&quot;),3)

## heatmap
ComplexHeatmap::pheatmap(gamma_wide_wna_reorder[,-1],cluster_cols = FALSE,drop_levels = TRUE,annotation_colors = ann_colors,annotation_row = pt_meta_wo6[,2:5],col = colorRampPalette(c(&quot;navy&quot;, &quot;white&quot;, &quot;firebrick3&quot;))(50),fontsize_row= 7,labels_col = col_labels,annotation_col = annotation_column, column_split = annotation_column$topics,cutree_rows = 4)</code></pre>
<p><img src="melanoma_files/figure-html/unnamed-chunk-18-1.png" width="960" /></p>
</div>
<div id="stackplot" class="section level3">
<h3>Stackplot</h3>
<p>LDA can not only identify the topics, but also quantify topic fraction within each sample. It can provide novel insights on complex immune phenotypes among patients and identify complex and unique pharmacodynamic changes upon treatment. We can also show topic fraction within each patient sample with stackplots, each at week 0, week 3, and week 6. Again, orange for <strong>exhaustion topic</strong>, green for <strong>naive topic</strong>, and blue for <strong>activation topic</strong>. For better separation, we use the same order for the patients as in the heatmap. The trends have been described in the heatmap.</p>
<pre class="r"><code>## add back data of 17-162-08, which has only week 0 data
## use the same patient order as in the heatmap
my_orders&lt;- c(rownames(gamma_wide_wna_reorder)[re$order],&quot;17-162-08&quot;)
my_labels&lt;-gsub(&quot;17-162*&quot;,&quot;&quot;,my_orders)
my_labels&lt;-gsub(&quot;-&quot;,&quot;&quot;,my_labels)

## stackplots for week 0,3,6
ps_list&lt;-list()
timepoint&lt;-c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;)
week&lt;-c(&quot;week0&quot;,&quot;week3&quot;,&quot;week6&quot;)
for (wk in 1:3){
  cols&lt;-paste0(c(&quot;topic1.&quot;,&quot;topic2.&quot;,&quot;topic3.&quot;),timepoint[wk])
  topic_fraction&lt;-gamma_wide_wna %&gt;% 
    select(cols,&quot;pt&quot;) %&gt;%  
    gather(key = &quot;Topic&quot;,value = &quot;fraction&quot;,-pt) %&gt;% na.omit()
  topic_fraction$Topic&lt;-as.factor(topic_fraction$Topic)
  levels(topic_fraction$Topic)&lt;-c(&quot;Naive topic&quot;, &quot;Exhaustion topic&quot;,&quot;Activation topic&quot;)
  
  p1&lt;-ggbarplot(topic_fraction,&quot;pt&quot;,&quot;fraction&quot;,fill = &quot;Topic&quot;,palette = c(&quot;#D55E00&quot;, &quot;#009E73&quot;,&quot;#0072B2&quot;),color = &quot;Topic&quot;)+scale_x_discrete(limits = my_orders[my_orders %in% topic_fraction$pt],labels = my_labels[my_orders %in% topic_fraction$pt])+ylab(&quot;Topic fraction&quot;)+xlab(&quot;Patient&quot;)
  ps_list[[wk]]&lt;-ggpar(p1,legend = &quot;none&quot;,title = week[wk],font.xtickslab  = c(5,&quot;bold&quot;),xtickslab.rt = 45)
}
wrap_plots(ps_list,guides = &quot;collect&quot;)</code></pre>
<p><img src="melanoma_files/figure-html/unnamed-chunk-19-1.png" width="1152" /></p>
<p><img src="melanoma_files/figure-html/unnamed-chunk-20-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
</div>
<div id="pharmacodynamics-of-patient-subgroups" class="section level2">
<h2>Pharmacodynamics of patient subgroups</h2>
<p>We may simply use boxplot to visualize the pharmacodynamics of topics within each patient subgroups. In the figure shown below, each subgroup exhibits distinct dynamic patterns within the three interpretable topics:</p>
<ul>
<li>Patients in groups 1 and 2 both have inferior increases in <strong>activation topic</strong>. Group 1 has the highest proportion of the <strong>exhaustion topic</strong> and group 2 has the highest <strong>naïve topic</strong> across time.</li>
<li>Patients in group 3 have the highest increase in the <strong>activation topic</strong> compared to other groups and are accompanied by the highest decrease in the <strong>naïve topic</strong> fraction.</li>
<li>Patients in group 4 has a high proportion of the <strong>naïve topic</strong> at week 0 and a moderate increase in the <strong>activation topic</strong>. Patients in group 4 are more likely to experience severe ICI-related toxicity compared to other groups.</li>
</ul>
<pre class="r"><code>## Parepare input data. add assigned group to each patient
integrate_data&lt;-merge(gamma_data,pt_meta_wo6[,c(1,5)],by.x = &quot;pt&quot;,by.y = &quot;pt&quot;)  
integrate_data_reformat&lt;-integrate_data %&gt;% 
  gather(key = &quot;Topic&quot;, value = &quot;Proportion&quot;,topic1, topic2, topic3)
integrate_data_reformat$week&lt;-as.factor(integrate_data$time)
levels(integrate_data_reformat$week)&lt;-c(0,3,6)


### boxplots show pharmacodynamics of four groups
color &lt;- c(group1 = &quot;#7570B3&quot;, group2 = &quot;#E7298A&quot;, group3 = &quot;#66A61E&quot;,group4 = &quot;#D95F02&quot;)
new_label&lt;-c(&quot;Exhaustion Topic&quot;,&quot;Naive Topic&quot;,&quot;Activation Topic&quot;)
names(new_label)&lt;-c(&quot;topic1&quot;,&quot;topic2&quot;,&quot;topic3&quot;)
ps_list&lt;-list()
groups&lt;-c(&quot;group1&quot;,&quot;group2&quot;,&quot;group3&quot;,&quot;group4&quot;)
for (group in groups){
  ps_list[[group]]&lt;-integrate_data_reformat %&gt;%
  filter(Group == group) %&gt;%
  ggboxplot(.,x = &quot;week&quot;, y = &quot;Proportion&quot;,add = &quot;point&quot;,fill = color[group])+geom_line(aes(group = pt),color = &#39;darkgray&#39;)+theme(legend.position = &quot;none&quot;)+facet_wrap(vars(Topic),nrow = 1,labeller = labeller(Topic = new_label))+ggtitle(group)
}
wrap_plots(ps_list,nrow = 4)</code></pre>
<p><img src="melanoma_files/figure-html/unnamed-chunk-21-1.png" width="1152" /></p>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeCodeFolding("show" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
